import copy
from collections import OrderedDict
from io import StringIO

import yaml
from sigma.backends.base import SingleTextQueryBackend
from sigma.parser.condition import SigmaAggregationParser
from sigma.parser.modifiers.base import SigmaTypeModifier
from sigma.parser.modifiers.type import SigmaRegularExpressionModifier

class SyntaxError(Exception):
    pass

class YeaBackend(SingleTextQueryBackend):
    """Base class for backends that generate one text-based expression from a Sigma rule"""
    ## see tools.py
    ## use this value when sigmac parse argument of "-t"
    identifier = "yea"
    ## see tools.py
    active = True

    # the following class variables define the generation and behavior of queries from a parse tree some are prefilled with default values that are quite usual
    andToken = " and "                  # Token used for linking expressions with logical AND
    orToken = " or "                    # Same for OR
    notToken = " not "                  # Same for NOT
    subExpression = "(%s)"              # Syntax for subexpressions, usually parenthesis around it. %s is inner expression
    valueExpression = "%s"              # Expression of values, %s represents value
    typedValueExpression = dict()       # Expression of typed values generated by type modifiers. modifier identifier -> expression dict, %s represents value

    sort_condition_lists = False
    mapListsSpecialHandling = True

    name_idx = 1
    selection_prefix = "SELECTION_{0}"
    name_2_selection = OrderedDict()

    def __init__(self, sigmaconfig, options):
        super().__init__(sigmaconfig)

    def cleanValue(self, val):
        return val

    def generateListNode(self, node):
        return self.generateORNode(node)

    def generateMapItemNode(self, node):
        # 以下のルールに対応。
        # logsource:
        #   product: windows
        #   service: system
        # detection:
        # EventID: 7045
        # TaskName:
        #   - 'SC Scheduled Scan'
        #   - 'UpdatMachine'
        #
        # 変換されて以下の形式でnodeが渡される
        # - LogName System
        # - EventID 7045
        # - TaskName ['SC Scheduled Scan', 'UpdatMachine']
        fieldname, value = node
        print("generateMapItemNode:     ", fieldname, value, self.name_idx)
        name = self.selection_prefix.format(self.name_idx)

        if self.mapListsSpecialHandling == False and type(value) in (str, int, list) or self.mapListsSpecialHandling == True and type(value) in (str, int):
            print("1")

            childValue = None
            if type(value) == str and "*" in value[1:-1]:
                childValue = self.generateValueNode(value)
            elif type(value) in (str, int):
                childValue = value
            else:
                childValue = self.generateNode(value)

            if name in self.name_2_selection:
                self.name_2_selection[name].append((fieldname, childValue))
                print(self.name_2_selection[name])
            else:
                self.name_2_selection[name] = [(fieldname, childValue)]
            return None
        elif type(value) == list:
            print("2")
            return self.generateMapItemListNode(fieldname, value)
        elif isinstance(value, SigmaTypeModifier):
            print("3")
            return self.generateMapItemTypedNode(fieldname, value)
        else:
            print("4")
            raise TypeError("Backend does not support map values of type " + str(type(value)))

    def generateMapItemTypedNode(self, fieldname, value):
        # `|re`オプションに対応
        if type(value) == SigmaRegularExpressionModifier:
            name = self.selection_prefix.format(self.name_idx)
            if name in self.name_2_selection:
                self.name_2_selection[name].append((fieldname, value))
            else:
                self.name_2_selection[name] = [(fieldname, value)]
        else:
            raise NotImplementedError("Type modifier '{}' is not supported by backend".format(value.identifier))

    def generateMapItemListNode(self, fieldname, value):
        ### 下記のようなケースに対応
        ### selection:
        ###     EventID:
        ###         - 1
        ###         - 2

        ### 基本的にリストはORと良く、generateListNodeもORNodeを生成している。
        ### しかし、上記のケースでgenerateListNode()を実行すると、下記のようなYAMLになってしまう。
        ### そうならないように修正している。
        ### なお、generateMapItemListNode()を有効にするために、self.mapListsSpecialHandling = Trueとしている
        ### selection:
        ###     EventID: 1 or 2
        print("generateMapItemListNode: ", fieldname, value)
        name = self.selection_prefix.format(self.name_idx)
        self.name_idx += 1
        values = [ self.generateNode(value_element) for value_element in value]
        # selection下に置かれるもの
        if name in self.name_2_selection:
            self.name_2_selection[name].append((fieldname, values))
        else:
            self.name_2_selection[name] = [(fieldname, values)]
        return name

    def generateAggregation(self, agg):
        # python3 tools/sigmac -rI rules/windows/builtin/ --config powershell-windows-all --target yea > result.yaml
        if agg == None:
            return ""
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_COUNT:
            # Example rule: ./rules/windows/builtin/win_global_catalog_enumeration.yml
            raise NotImplementedError("COUNT aggregation operator is not yet implemented for this backend")
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_MIN:
            raise NotImplementedError("MIN aggregation operator is not yet implemented for this backend")
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_MAX:
            raise NotImplementedError("MAX aggregation operator is not yet implemented for this backend")
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_AVG:
            raise NotImplementedError("AVG aggregation operator is not yet implemented for this backend")
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_SUM:
            raise NotImplementedError("SUM aggregation operator is not yet implemented for this backend")
        if agg.aggfunc == SigmaAggregationParser.AGGFUNC_NEAR:
            # Example rule: ./rules/windows/builtin/win_susp_samr_pwset.yml
            raise NotImplementedError("NEAR aggregation operator is not yet implemented for this backend")

    def generateQuery(self, parsed):
        result = self.generateNode(parsed.parsedSearch)
        if parsed.parsedAgg:
            result += self.generateAggregation(parsed.parsedAgg)
        ret = ""
        with StringIO() as bs:
            ## 元のyamlをいじるとこの後の処理に影響を与える可能性があるので、deepCopyする
            parsed_yaml = copy.deepcopy(parsed.sigmaParser.parsedyaml)

            ## なんかタイトルは先頭に来てほしいので、そのための処理
            ## parsed.sigmaParser.parsedyamlがOrderedDictならこんなことしなくていい、後で別のやり方があるか調べる
            bs.write("title: " + parsed_yaml["title"]+"\n")
            del parsed_yaml["title"]

            ## detectionの部分だけ変更して出力する。
            parsed_yaml["detection"] = {}
            parsed_yaml["detection"]["condition"] = result
            for key, values in self.name_2_selection.items():
                parsed_yaml["detection"][key] = {}
                for fieldname, value in values:
                    print(fieldname, value)
                    if type(value) == str and "*" in value and fieldname in parsed_yaml["detection"][key]:
                        parsed_yaml["detection"][key][fieldname] = mergeContexts(parsed_yaml["detection"][key][fieldname], value)
                    else:
                        parsed_yaml["detection"][key][fieldname] = value

            print(parsed_yaml)
            yaml.dump(parsed_yaml, bs, indent=4, default_flow_style=False)
            ret = bs.getvalue()

        return ret

def mergeContexts(param1, param2):
    """
    以下のような形式で同一のパラメータに対してANDをかけていた場合、
    条件をマージする。
    selection_process2:
        Image|contains: '\Windows\Temp\DB\'
        Image|endswith: '.exe'
    ↓
    selection_process2:
        Image: '*\Windows\Temp\DB\\*.exe'
    """
    if param1 == param2:
        return param1

    if not param1.startswith("*"):
        # Startwith x XXX
        if param2.startswith("*"):
            return param1 + param2[1:]
        else:
            raise SyntaxError("Rule was not good. If you want to make 'startswith' section in same field, use OR node", param1, param2, type(param1))

    if not param2.startswith("*"):
        # Startswith x XXX
        if param1.startswith("*"):
            return param2 + param1[1:]
        else:
            raise SyntaxError("Rule was not good. If you want to make 'startswith' section in same field, use OR node")

    if not param1.endswith("*"):
        # Endwith x Endswith
        # Endswith x Contains
        if param2.endsswith("*"):
            return param2 + param1[1:]
        else:
            raise SyntaxError("Rule was not good. If you want to make 'endswith' section in same field, use OR node")

    if not param2.endswith("*"):
        # Endswith x Endswith
        # Endswith x Contains
        if param1.endswith("*"):
            return param1 + param2[1:]
        else:
            raise SyntaxError("Rule was not good. If you want to make 'endswith' section in same field, use OR node")

    raise NotImplementedError("Error", param1, param2)
