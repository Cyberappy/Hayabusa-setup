import sys

from collections import OrderedDict
from sigma.backends.base import SingleTextQueryBackend
from sigma.parser.modifiers.base import SigmaTypeModifier
from io import StringIO
import yaml
import copy

class YeaBackend(SingleTextQueryBackend):
    """Base class for backends that generate one text-based expression from a Sigma rule"""
    ## see tools.py 
    ## use this value when sigmac parse argument of "-t" 
    identifier = "yea"
    ## see tools.py
    active = True

    # the following class variables define the generation and behavior of queries from a parse tree some are prefilled with default values that are quite usual
    andToken = " and "                  # Token used for linking expressions with logical AND
    orToken = " or "                    # Same for OR
    notToken = " not "                  # Same for NOT
    subExpression = "(%s)"              # Syntax for subexpressions, usually parenthesis around it. %s is inner expression
    valueExpression = "%s"              # Expression of values, %s represents value
    typedValueExpression = dict()       # Expression of typed values generated by type modifiers. modifier identifier -> expression dict, %s represents value
    mapListsSpecialHandling = True
    sort_condition_lists = False

    name_idx = 1
    selection_prefix = "SELECTION_{0}"
    name_2_selection = OrderedDict()

    def __init__(self, sigmaconfig, options):
        super().__init__(sigmaconfig)

    def cleanValue(self, val):
        return val

    def generateListNode(self, node):
        return self.generateORNode(node)

    def generateMapItemTypedNode(self, fieldname, value):
        name = self.selection_prefix.format(self.name_idx)
        self.name_idx += 1
        self.name_2_selection[name] = (fieldname, self.generateNode(value))
        return name

    def generateMapItemListNode(self, fieldname, value):
        ### 下記のようなケースに対応
        ### selection:
        ###     EventID:
        ###         - 1
        ###         - 2

        ### 基本的にリストはORと良く、generateListNodeもORNodeを生成している。
        ### しかし、上記のケースでgenerateListNode()を実行すると、下記のようなYAMLになってしまう。
        ### そうならないように修正している。
        ### なお、generateMapItemListNode()を有効にするために、self.mapListsSpecialHandling = Trueとしている
        ### selection:
        ###     EventID: 1 or 2
        print("tes: " + fieldname + str(value))
        name = self.selection_prefix.format(self.name_idx)
        self.name_idx += 1
        values = [ self.generateNode(value_element) for value_element in value]
        self.name_2_selection[name] = (fieldname, values)
        return name

    def generateQuery(self, parsed):
        print("\n")
        print(parsed.sigmaParser.parsedyaml)
        result = self.generateNode(parsed.parsedSearch)
        if parsed.parsedAgg:
            result += self.generateAggregation(parsed.parsedAgg)
        ret = ""
        with StringIO() as bs:
            ## 元のyamlをいじるとこの後の処理に影響を与える可能性があるので、deepCopyする
            parsed_yaml = copy.deepcopy(parsed.sigmaParser.parsedyaml)

            ## なんかタイトルは先頭に来てほしいので、そのための処理
            ## parsed.sigmaParser.parsedyamlがOrderedDictならこんなことしなくていい、後で別のやり方があるか調べる
            bs.write("title: " + parsed_yaml["title"]+"\n")
            del parsed_yaml["title"]

            ## detectionの部分だけ変更して出力する。
            parsed_yaml["detection"] = {}
            parsed_yaml["detection"]["condition"] = result
            for key, val in self.name_2_selection.items():
                parsed_yaml["detection"][key] = {}
                parsed_yaml["detection"][key][val[0]] = val[1]

            yaml.dump(parsed_yaml, bs, indent=4, default_flow_style=False)
            ret = bs.getvalue()

        return ret
